"use strict";(globalThis.webpackChunkstardust_website=globalThis.webpackChunkstardust_website||[]).push([[9174],{6902:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"dive-deeper/deep-overview","title":"Technical Overview","description":"Server","source":"@site/docs/03-dive-deeper/02-deep-overview.md","sourceDirName":"03-dive-deeper","slug":"/dive-deeper/deep-overview","permalink":"/docs/dive-deeper/deep-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/StardustXR/website/edit/main/docs/03-dive-deeper/02-deep-overview.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Brief Overview","permalink":"/docs/dive-deeper/brief-overview"},"next":{"title":"Making Clients","permalink":"/docs/dive-deeper/make-clients"}}');var t=i(4848),r=i(8453);const a={sidebar_position:2},o="Technical Overview",l={},d=[{value:"Server",id:"server",level:2},{value:"Reference Server",id:"reference-server",level:3},{value:"IPC",id:"ipc",level:2},{value:"Protocol",id:"protocol",level:2},{value:"Clients",id:"clients",level:2}];function c(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"technical-overview",children:"Technical Overview"})}),"\n",(0,t.jsx)(n.h2,{id:"server",children:"Server"}),"\n",(0,t.jsx)(n.p,{children:"The server is what renders all the meshes of each client, takes in input from input methods, and spits out input to input handlers according to the SUIS (Spatial Universal Interaction System). As well, the server is going to be part Wayland compositor and OpenXR runtime so all 2D and XR applications can be used together at once (if the hardware allows). It is the glue of Stardust, allowing any number of clients and apps to work in harmony while allowing the user full control in an intuitive way."}),"\n",(0,t.jsx)(n.p,{children:"As new technologies come out, keeping the same server and trying to progressively upgrade it may lead to bloat and issues, so the protocol is designed to make creating new servers possible without too much hassle or to make servers modular. Old interfaces can be deprecated without breaking the overall system, and new interfaces can be added if needed due to the object-oriented design. The design is highly inspired by game engines, however the reference server is made in StereoKit due to it being more optimal."}),"\n",(0,t.jsx)(n.h3,{id:"reference-server",children:"Reference Server"}),"\n",(0,t.jsx)(n.p,{children:"Stardust has a reference server, but unlike other display servers this reference server is just as functional as any other Stardust server would be, because all the functionality is implemented in the clients. The server is just the glue."}),"\n",(0,t.jsx)(n.p,{children:"The reference server uses StereoKit as its backend for many reasons:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Much more lightweight than any other framework/other engine","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It was originally designed to run AR apps on HoloLens, and now it works on Quest"}),"\n",(0,t.jsx)(n.li,{children:"It's able to render thousands of objects on a HoloLens without breaking a sweat"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Does not include unnecessary features that slow down performance","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Physics and UI are not needed for Stardust, but those do not actively run and can always have an option to not be compiled at all."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Uses C-style C++ meaning not bytecode or interpreted (however has a C# API that is not used by Stardust)"}),"\n",(0,t.jsx)(n.li,{children:"Uses immediate mode rendering meaning the logic is many times easier to implement"}),"\n",(0,t.jsxs)(n.li,{children:["Exposes its rendering insides whenever needed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Very needed for Wayland when it needs to display EGL Wayland surface textures on meshes"}),"\n",(0,t.jsx)(n.li,{children:"Overriding the depthbuffer per-pixel in fragment shader is useful for XR depth compositing"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Is constantly getting new updates faster than most engines","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"World semantics for OpenXR was implemented ~1 week after the official OpenXR extension release"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Is optimized to load resources JIT","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Many game engines are best at caching their assets, but this is not practical in a display server"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Uses OpenXR as its backend out of the box"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ipc",children:"IPC"}),"\n",(0,t.jsx)(n.p,{children:"The Stardust XR IPC uses Unix domain sockets for communication and a protocol based on flatbuffers/flexbuffers."}),"\n",(0,t.jsx)(n.h2,{id:"protocol",children:"Protocol"}),"\n",(0,t.jsx)(n.p,{children:"The Stardust XR protocol is object-oriented, depending on a scenegraph on the server end and scenegraph or functionally equivalent structure on the client end. This allows easier implementation of the protocol while still remaining fast, reliable, and extensible."}),"\n",(0,t.jsx)(n.h2,{id:"clients",children:"Clients"}),"\n",(0,t.jsx)(n.p,{children:"The clients tell the server what models to draw, where they would like to accept input in, etc. Stardust clients are much more suited to widgets or user interfaces to 2D/XR apps."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);